---
title: "HUGEN 2072 Project 1"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

```

# Instructions

Below is a tutorial consisting of a mostly-completed QC pipeline and some prompts.

Project 1 has three components:

-   **Scripting/coding**: read through this file and complete the pipeline by contributing your code *where indicated*.

-   **Narrative**: knit the completed .Rmd to a code-integrated HTML report of your QC process and decisions.

    -   Your report must answer all the questions and perform all the tasks indicated in the instructions/prompts given for each step.

    -   You must submit a successfully-knitted HTML file and the `.Rmd` in order to earn a passing grade for this project.

    -   Set up your report to flow like an actual document you might show your supervisor to summarize the QC project, emphasizing what was done at each step rather than the code used to do it (e.g., how many samples/SNPs were filtered out at a given step?)

    -   **Submit your .Rmd and HTML to Canvas**

-   **Presentation**: you will make a 10 min (maximum) recording of yourself with Panopto in which you summarize this QC pipeline. Instructions will given on Canvas.

In each Part of this project you will implement one of the main steps of cleaning genotyping array data in a small dataset (note that we left a few steps out). You'll be shown how to use functions from the `{GWASTools}` package, and you'll supply a little of your own code to complete the pipeline that's been provided. At each step, you may be asked to create a filter for the data, to address errors/discrepancies, etc. Then for each step you'll make a short report (a few sentences and figures) explaining what you did.

Note that "sample" and "scan" are used interchangeably throughout this assignment, but that these are NOT synonymous with subject/participant/individual/etc. In this assignment, "SNP" and "probe" are used interchangeably, but in other contexts you should always remember the distinction.

**Since the pipeline below is incomplete, some of the R code chunks are set to `eval=FALSE` so that knitting to HTML will succeed. You will need to change them to `eval=TRUE` as you progress so that your knitted document shows the results of running each chunk.**

**It is expected that you will copy this file somewhere to your directory on the CRC cluster so that you can use the RStudio Server, where all the packages you need have been installed already.**

## Part 0 - Setup and Introduction to Annotation Data Frames

First, load the packages we'll be using.

```{r load_packages, message=F, eval=TRUE}

# Load the required packages for the project (Install them if necessary)

library("GWASTools", quietly = TRUE)
library("GWASdata", quietly = TRUE)
library("SNPRelate", quietly = TRUE)

# Close any open GDS files before proceeding (think of this as starting off with
# a 'blank slate')

showfile.gds(closeall = T, verbose = T)

```

The array data (genotypes, intensities, and BAF/LRR information) for this project are contained in several GDS files; accompanying SNP and scan annotation are also provided as an `.RData` file.

The probe/SNP annotation is stored in an object called a scan annotation data frame, and the sample-level annotation is stored in a scan annotation data frame. Each of these objects is similar to an ordinary data frame. More precisely, a data frame is embedded within each. There is also accompanying metadata. To access the data and metadata, the `{GWASTools}` package provides several functions. Three basic functions you should familiarize yourself with are `getAnnotation()`/`pData()` (extracts a standard data frame containing the annotation), `getMetadata()`/`varMetadata()` (extracts a data frame of variable descriptions), and `getVariableNames()`/`varLabels()` (extracts a vector of just the variable names). You can also view a variable in one of these objects by using `$`, as you would for an ordinary data frame. You can also add new variables, but you need to be careful to update the metadata as well. Since we will be adding new variables in the process of cleaning our data, the following chunk of code shows you how to do this. Then you will practice looking at the annotation, and your task is to answer some questions about this data set.

First, load the annotation data (`annotation_data.RData`) that was provided with this project. **You need to supply the path to this file.**

```{r load_annotation, eval=TRUE}

# Load the probe (SNP) and sample annotation data frames, which have been saved
# in an .RData file

path_to_annotation_data <-
  "/ix1/hugen2072-2026s/p1/annotation_data.RData"
load(path_to_annotation_data)

# List the loaded objects

ls()

```

Here's a toy example showing you how to work with annotation data frames. **Read this carefully, since you'll need to do this throughout the assignment.**

```{r annotation_data_frame_example, eval=TRUE}

### How to add a new variable to an annotation data frame ###

#   Make a new copy of the SNP annotation (just for this example)
snp_annodf_temp <- snpAnnot

#   Notice that printing the object isn't that helpful
snp_annodf_temp

#   So extract the annotation itself (this is the 'normal' data frame embedded
#   in the SNP annotation data frame object). Now you can see the SNP-level
#   annotation
snp_data_temp <- getAnnotation(snp_annodf_temp)
head(snp_data_temp)

#   Add a new column to the annotation (an integer dummy variable)
snp_data_temp$dummy <- 1:nrow(snp_data_temp)

#   Now update the scan annotation object itself by replacing the what was in
#   the annotation "slot"
pData(snp_annodf_temp) <- snp_data_temp

#   You can see that the new column has been added
head(pData(snp_annodf_temp))

#   Extract the metadata so that it can be updated
meta_temp <- getMetadata(snp_annodf_temp)
meta_temp

#   Add a new row titled "dummy" with an appropriate labelDescription (note that
#   the metadata is a data frame with named rows but one column)
meta_temp["dummy", "labelDescription"] <- "This is a dummy variable"

#   Finally, replace the old metadata with the new metadata
varMetadata(snp_annodf_temp) <- meta_temp

#   Look at the data and metadata to make sure there the dummy variable has been
#   added
head(getAnnotation(snp_annodf_temp))
getMetadata(snp_annodf_temp)

#   Remove the temp files
rm(snp_annodf_temp, snp_data_temp, meta_temp)

```

Now we use `GdsGenotypeReader()` and `GdsIntensityReader()` to open the gds files that contain the array data. Then use `GenotypeData()` and `IntensityData()` to combine them with the SNP and sample annotation, since the functions we'll be using later require this information to be "packaged" together.

```{r load_array_data, eval=TRUE}

#   Get the genotypes from a gds file
genofile <-
  system.file("extdata", "illumina_geno.gds", package = "GWASdata")
gds_geno <- GdsGenotypeReader(genofile)

#   Combine the genotypes with the sample and SNP annotation
genoData <-
  GenotypeData(gds_geno, snpAnnot = snpAnnot, scanAnnot = scanAnnot)
genoData

#   Get the intensity data from a gds file
qxyfile <-
  system.file("extdata", "illumina_qxy.gds", package = "GWASdata")
gds_qxy <- GdsIntensityReader(qxyfile)

#   Combine with the sample and SNP annotation
qxyData <-
  IntensityData(gds_qxy, snpAnnot = snpAnnot, scanAnnot = scanAnnot)
qxyData

#   Get the BAF/LRR data from a gds file
blfile <-
  system.file("extdata", "illumina_bl.gds", package = "GWASdata")
gds <- GdsIntensityReader(blfile)

#   Combine the BAF/LRR data with the sample and SNP annotation
blData <-
  IntensityData(gds, snpAnnot = snpAnnot, scanAnnot = scanAnnot)
blData

```

## Part 0 - Report

Using the functions introduced above to help you, briefly describe the dataset in a few sentences. Answer the following questions. Whatever code you use to help answer these questions can go in the empty chunk that follows.

-   [What is the difference between the scanID and subjectID variables? Why are they both provided?]{.underline}

    -   A subjectID is an identifier for a person, and each subject can have multiple scanIDs (samples) in the data. It's important to have all of these samples listed with their respective subject IDs to keep track of the individuals in the study.

-   [How many families are represented, and how many samples are from each family?]{.underline}

    -   13 families are represented. The breakdown of samples from each family is listed in the code block below.

-   [How many samples are of each sex?]{.underline}

    -   42 male samples and 35 female samples

-   [How many samples are from each population group?]{.underline}

    -   CEU – 49 samples.

    -    YRI – 28 samples.

-   [How many samples are there? How many people did they come from?]{.underline}

    -   There are 77 samples (scans), which came from 43 people.

-   [How many SNPs are there?]{.underline}

    -   3300 SNPs.

-   [Which chromosomes are represented? How many SNPs are on each?]{.underline}

    -   There are 6 chromosomes represented– 21 22 23 24 25 26.

        -   chr 21: 1000 SNPs

        -   chr 22: 1000 SNPs

        -   chr 23: 1000 SNPs

        -   chr 24: 100 SNPs

        -   chr 25: 100 SNPs

        -   chr 26: 100 SNPs

```{r part0_report}
library(tidyverse)

# Your code goes here
snp <- pData(snpAnnot)
scan <- pData(scanAnnot)
head(snp)
head(scan)

# How many families are represented, and how many samples are from each family?
print('families')
length(unique(scan$family))
table(scan$family)

# How many samples are of each sex?
scan %>%
  filter(sex == 'M') %>%
  count() # 44
scan %>%
  filter(sex == 'F') %>%
  count() # 33

# How many samples are from each population group?
print('race')
table(scan$race)

# How many samples are there? How many people did they come from?
print('subjects')
length(unique(scan$subjectID))

# how many snps
print('snps')
length(unique(snp$snpID))

# which chromosomes
print('chromosomes')
table(snp$chromosome)
```

## Part 1 - Missing Call Rate for Samples and SNPs

The basic `{GWASTools}` functions for missingness are `missingGenotypeBySnpSex()` and `missingGenotypeByScanChrom()`. `missingGenotypeBySnpSex()` returns a list of three objects: `missing.counts`, `scans.per.sex`, and `missing.fraction`. Read the help file for this function so that you understand what information is contained in these and how the Y chromosome is treated by sex (where sex is as defined in the scan annotation). Similarly, `missingGenotypeByScanChrom()` returns `missing.counts`, `snps.per.chr`, and `missing.fraction`.

There are four basic missingness calculations to be done, in the following order.

1.  Calculate `missing.n1` = fraction of genotype calls missing over all samples (except that annotated ‘female’ individuals are excluded for Y chr SNPs)

2.  Calculate `missing.e1` = missing call rate per sample over all SNPs (excluding SNPs with all calls missing)

3.  Calculate `missing.n2` = missing call rate per SNP over all samples whose `missing.e1` is less than `0.05`

4.  Calculate `missing.e2` = missing call rate per sample over all SNPs with `missing.n2` values less than `0.05`

We'll want to store the missingness information in the annotation data frames as we proceed.

Here's how to calculate and store `missing.n1`.

```{r missing.n1, eval=TRUE}

### Using missingGenotypeBySnpSex to calculate missing.n1 ###

#   First look at some of the results
miss <- missingGenotypeBySnpSex(genoData)
names(miss)
head(miss$missing.counts)
miss$scans.per.sex
head(miss$missing.fraction)

#   We should make sure the snpIDs are in the same order in the annotation and
#   in the missingness report (miss$missing.fraction); they are
allequal(snpAnnot$snpID, as.numeric(names(miss$missing.fraction)))

#   Then go ahead and add missing.n1 as a new annotation data column, and update
#   the metadata
snpAnnot$missing.n1 <- miss$missing.fraction
varMetadata(snpAnnot)["missing.n1", "labelDescription"] <-
  paste(
    "fraction of genotype calls missing over all samples, except that females are excluded for Y chr SNPs"
  )

### Explore the missing call rate per probes a little more

#   Look at the distribution of missingness for all the probes
hist(
  snpAnnot$missing.n1,
  ylim = c(0, 100),
  xlab = "SNP missing call rate",
  main = "Missing Call Rate for All Probes"
)

#   How many SNPs are missing a genotype for every single sample? Apparently
#   there are 151 such SNPs
sum(snpAnnot$missing.n1 == 1)

#   Store a vector containing the snpIDs of all the SNPs with missingness of
#   100%
snpexcl <- snpAnnot$snpID[snpAnnot$missing.n1 == 1]

```

Now we calculate and store `missing.e1`. The steps are described in the comments below.

```{r missing.e1, eval=TRUE}
# EXAMPLE CODE

### Using missingGenotypeByScanChrom to calculate missing.e1

#   Apply missingGenotypeByScanChrom to genoData, using the snp.exclude option
#   to exclude these SNPs (why does it make sense to exclude those SNPs?)
miss <- missingGenotypeByScanChrom(genoData, snp.exclude = snpexcl)

#   Make sure the order of the scanIDs in the output from
#   missingGenotypeByScanChrom is the same as the order of the scanIDs in the
#   annotation data frame
allequal(names(miss$missing.fraction), scanAnnot$scanID)

#   Make a new column in scanAnnot called missing.e1 and store the per-scan
#   missingness from missingGenotypeByScanChrom there
scanAnnot$missing.e1 <- miss$missing.fraction

#   Update the scanAnnot metadata
varMetadata(scanAnnot)["missing.e1", "labelDescription"] <-
  "fraction of genotype calls missing over all snps with missing.n1<1 except that Y chr SNPs are excluded for females"

# We can check summary statistics and make a histogram, too
summary(scanAnnot$missing.e1)
hist(
  scanAnnot$missing.e1,
  xlab = "Fraction of missing calls over all probes",
  main = "Histogram of Sample Missing Call Rate for All Samples",
)

```

Now, supply your code to calculate and store `missing.n2`. The steps you should follow are described in the comments below.

```{r missing.n2, eval=TRUE}

### Now that missing.n1 and missing.e1 have been calculated, we can calculate missing.n2

#   Recall that missing.n2 = missing call rate per SNP over all samples whose missing.e1
#   is less than 0.05.

#   Since no sample had missing.e1 > 0.05 in this dataset, we don't actually
#   have to exclude any samples.

#   However, let's proceed as if there were some samples with missing.e1 > 0.05.

#   Make a vector of the scanIDs for the samples with high missing.e1.

#   Apply the missingGenotypeBySnpSex function again, using the scan.exclude
#   argument.

#   Store missing.n2 as a new column in snpAnnot.

#   Update the metadata for snpAnnot!

#   The labelDescription for missing.n2 should be "fraction of genotype calls
#   missing over all samples with missing.e1 < 0.05 except that females are
#   excluded for Y chr SNPs"

#   <Your code goes here> ########################################

#   Make a vector of the scanIDs for the samples with high missing.e1.
snpexcl2 <- snpAnnot$snpID[snpAnnot$missing.e1 > 0.05]

#   Apply the missingGenotypeBySnpSex function again, using the scan.exclude
#   argument.
miss2 <- missingGenotypeBySnpSex(genoData, scan.exclude = snpexcl2) 

#   Store missing.n2 as a new column in snpAnnot.
snpAnnot$missing.n2 <- miss2$missing.fraction

#   Update the metadata for snpAnnot!
varMetadata(snpAnnot)["missing.n2", "labelDescription"] <-
  "fraction of genotype calls missing over all samples with missing.e1 < 0.05 except that females are excluded for Y chr SNPs"

# should make a histogram to see also
summary(snpAnnot$missing.n2)
hist(
  snpAnnot$missing.n2,
  xlab = "Fraction of call rate per SNP over all samples whose missing.e1 < 0.05",
  main = "Missing call rate per SNP over all samples whose missing.e1 < 0.05.",
  col = 'lightblue'
)

```

Write code to calculate and store `missing.e2`. The steps you should follow are described in the comments below.

```{r missing.e2, eval=TRUE}

### Last, we calculate missing.e2

#   Recall missing.e2 = missing call rate per sample over all SNPs with
#   missing.n2 values less than 0.05

#   Store a vector with the snpIDs of all probes with missing.n2 >= 0.05

#   Apply missingGenotypeByScanChrom to genoData again, using the snp.exclude
#   argument to exclude the SNPs with missing.n2 >= 0.05 (why do we do this?)

#   Make a new column in scanAnnot called missing.e2 to store the missingness
#   per-scan you just calculated

#   Update the scanAnnot metadata

#   The labelDescription should say "fraction of genotype calls missing over all
#   snps with missing.n2 < 0.05 except that Y chr SNPs are excluded for females"

#   <Your code goes here> ########################################

#   Store a vector with the snpIDs of all probes with missing.n2 >= 0.05
snpexcl3 <- scanAnnot$snpID[scanAnnot$missing.n2 >= 0.05]

#   Apply missingGenotypeByScanChrom to genoData again, using the snp.exclude
#   argument to exclude the SNPs with missing.n2 >= 0.05 (why do we do this?)
miss3 <- missingGenotypeByScanChrom(genoData, snp.exclude = snpexcl3) 

#   Make a new column in scanAnnot called missing.e2 to store the missingness
#   per-scan you just calculated
scanAnnot$missing.e2 <- miss$missing.fraction

#   Update the scanAnnot metadata
varMetadata(scanAnnot)["missing.e2", "labelDescription"] <-
  "fraction of genotype calls missing over all snps with missing.n2 < 0.05 except that Y chr SNPs are excluded for females"

# histogram 
summary(scanAnnot$missing.e2)
hist(
  scanAnnot$missing.e2,
  xlab = "Fraction of MCR per sample over all SNPs with missing.n2 values < 0.05",
  main = "Missing call rate per sample over all SNPs with missing.n2 < 0.05",
  col = 'mediumpurple'
)
```

## Part 1 - Report

Summarize the filtering you've accomplished at this step. Include the following in your answer the following questions.

-   (First, make sure you've filled in the calculations of `missing.n2` and `missing.e2` in the chunks above.)

-   [How many SNPs and samples were genotyped?]{.underline}

    -   3300 SNPs and 77 samples exist, and 3149 (the ones who do not have 100% missingness) SNPs and 77 samples were genotyped.

-   [Briefly describe the purpose of doing this step in two rounds (why do we calculate both missingnesses twice?)]{.underline}

    -   We first store a vector of the snpIDs that exceed the missingness threshold, and then we use that vector to exclude these snpIDs from the dataset.

-   [What were the median, mean, and maximum per-sample missingness (use `missing.e2`)? Make a histogram of `missing.e2`.]{.underline}

    -   Median: 0.0022229

    -   Mean: 0.0032162

    -   Maximum: 0.0247827

    -   (See histogram of missing.e2 above, in purple.)

-   [How many samples had no missing calls at all (use `missing.e2`)?]{.underline}

    -   1 sample with MCR = 0? (ScanID 321)

-   [Are the samples generally "good"? How many should be excluded from downstream analyses?]{.underline}

    -   The samples seem pretty good– the majority of missing.n2 MCR = 0%, and the maximum of missing.e2 is under 0.025. I don't see any that should be excluded from downstream analyses until further investigation.

-   [How many SNPs had a 100% missing call rate (use `missing.n1`)?]{.underline}

    -   151 SNPs had a 100% missing call rate (MCR = 1).

-   [What are the median, mean, and maximum per-SNP missingnesses (use `missing.n2`)? How many SNPs are missing no calls at all?]{.underline}

    -   Median: 0.00000

    -   Mean: 0.04898

    -   Maximum: 1.00000

    -   2,755 SNPs are missing no calls (MCR = 0).

-   [Make a histogram of `missing.n2`.]{.underline}

    -   (See histogram of missing.n2 above, in light blue.)

-   [How many SNPs are filtered out and how many remain if you retain only SNPs with `missing.n2` \< 0.05?]{.underline}

    -   3,095 SNPs remain after filtering by missing.n2 \<0.05, meaning 205 SNPs were filtered out (from 3,300 SNPs total)

-   [Make a histogram showing `missing.n2` for the remaining SNPs.]{.underline}

    -   (See histogram of missing.n2 for remaining SNPs below, in dark blue)

```{r part1_report}
library(ggplot2)

#   <Your code goes here>
sc <- pData(scanAnnot) # e1, e2
sn <- pData(snpAnnot) # n1, n2
head(sc) 
head(sn)

# How many SNPs and samples were genotyped?
sn %>%
  filter(missing.n1 != 1) %>%
  count() # 3149 

# missing.e2 histogram 
summary(scanAnnot$missing.e2)
hist(
  scanAnnot$missing.e2,
  xlab = "Fraction of MCR per sample over all SNPs with missing.n2 values < 0.05",
  main = "Missing call rate per sample over all SNPs with missing.n2 < 0.05",
  col = 'mediumpurple'
)

# How many samples had no missing calls at all (use missing.e2)?
sc %>%
  filter(missing.e2 == 0) # 1? is this not meant to be 6???

# How many SNPs had a 100% missing call rate (use missing.n1)?
sn %>%
  filter(missing.n1 == 1) %>%
  count() # 151

# missing.n2 histogram
summary(snpAnnot$missing.n2)
hist(
  snpAnnot$missing.n2,
  xlab = "Fraction of call rate per SNP over all samples whose missing.e1 < 0.05",
  main = "Missing call rate per SNP over all samples whose missing.e1 < 0.05.",
  col = 'lightblue'
)

# What are the median, mean, and maximum per-SNP missingnesses (use missing.n2)? How many SNPs are missing no calls at all?
sn %>%
  filter(missing.n2 == 0) %>%
  count() # 2755

# How many SNPs are filtered out and how many remain if you retain only SNPs with missing.n2 < 0.05?
sn %>% 
  filter(missing.n2 < 0.05) %>%
  count() # 3095

# Make a histogram showing missing.n2 for the remaining SNPs.
hist(
sn$missing.n2[sn$missing.n2 < 0.05], # would be nice if base R cooperated with tidyverse
xlab = "Fraction of call rate per SNP after retaining SNPs with missing.n2 <0.05",
main = "Histogram of missing.n2 for remaining SNPs",
col = 'darkblue'
)
  
```

## Part 2 - Inferred vs. Reported Sex and Relatedness

To investigate discrepancies in inferred vs. reported sex (and, possibly, sex chromosome aneuploidies), we will produce four plots that summarize each scan's heterozygosity and intensity for the sex chromosomes:

1.  Mean Y chromosome vs. mean X chromosome intensity

2.  Mean X chromosome heterozygosity vs. mean X chromosome intensity

3.  Mean Y chromosome intensity vs. mean X chromosome heterozygosity

4.  Mean X chromosome heterozygosity vs. autosomal heterozygosity

Recall that the intensity data was read in earlier as `qxyData`. Before making our graphs, we'll need to calculate the variables we want to plot. The basic function we'll use to do this is `meanIntensityByScanChrom()`, which will return a list of matrices. Read the help file of this function so that you understand the output. Heterozygosity is calculated with `hetByScanChrom()`.

```{r sex_check, eval=TRUE}
# EXAMPLE CODE

#   Look at the structure of the IntensityData object
qxyData

#   For each probe, there's a numerical ID, chromosome, position, rsID

#   The intensities (stored as variables called X and Y) are each essentially
#   3300×77 matrices (an X and Y intensity for each scan for every single probe)

#   (Don't confuse the *intensity variable names* _X_ and _Y_ in the IntensityData
#   object with the X and Y *chromosomes*!)

#   Apply the meanIntensityByScanChrom function to get the intensity averages.
#   (We're not going to use all of the output from this function)
inten.by.chrom <- meanIntensityByScanChrom(qxyData)

#   Extract the matrix containing the mean intensity for each chromosome for
#   each scan
names(inten.by.chrom)
mninten <- inten.by.chrom$mean.intensity

#   The matrix is 77x6 since there are 77 samples and 6 chromosomes represented
#   in the dataset
dim(mninten)
head(mninten)

#   We also need to calculate the X chromosome and autosome heterozygosities for
#   each sample before we can plot them

#   Apply hetByScanChrom to genoData (we need actual genotypes to calculate the
#   heterozygosity)
het.results <- hetByScanChrom(genoData)

#   The function calculates eachs scan's heterozygosity for each chromosome, and
#   also for the autosomes as a whole

#   We want to add X and autosome heterozygosity as new columns in scanAnnot

#   Make sure the scanIDs are in the right order first! (they are)
allequal(scanAnnot$scanID, rownames(het.results))

#   Extract the autosomal and X heterozygosity and store them in scanAnnot
scanAnnot$het.A <- het.results[, "A"]
scanAnnot$het.X <- het.results[, "X"]

#   Add appropriate metadata
varMetadata(scanAnnot)["het.A", "labelDescription"] <-
  "fraction of heterozygotes for autosomal SNPs"
varMetadata(scanAnnot)["het.X", "labelDescription"] <-
  "fraction of heterozygotes for X chromosome SNPs"

#   Before making the plots, there are a few things to do

#   We want to color the plotted points by annotated sex

#   But first, make sure that the order of the scanIDs (and hence the annotated
#   sexes) matches the order of the scanIDs in the data we'll plot
allequal(scanAnnot$scanID, rownames(mninten))

#   Now we assign each sex a color (male=blue, female=red)

#   Store the colors in a vector
xcol <- rep(NA, nrow(scanAnnot))
xcol[scanAnnot$sex == "M"] <- "blue"
xcol[scanAnnot$sex == "F"] <- "red"

#   We also want to count the number of SNPs getting included on the X and Y
#   chromosomes (which are coded as 23 and 25 in snpAnnot)
nx <- sum(snpAnnot$chromosome == 23)
ny <- sum(snpAnnot$chromosome == 25)

# Now make the plots

# All intensities
x1 <- mninten[, "X"]
y1 <- mninten[, "Y"]
main1 <- "Mean X vs \nMean Y Chromosome Intensity"

# Het on X vs X intensity
x2 <- mninten[, "X"]
y2 <- scanAnnot$het.X
main2 <-
  "Mean X Chromosome Intensity vs Mean X Chromosome Heterozygosity"

# Het on X vs Y intensity
y3 <- mninten[, "Y"]
x3 <- scanAnnot$het.X
main3 <-
  "MeanX Chromosome Heterozygosity vs Mean Y Chromosome Intensity"

# X vs A het
x4 <- scanAnnot$het.A[scanAnnot$sex == "F"]
y4 <- scanAnnot$het.X[scanAnnot$sex == "F"]
main4 <-
  "Mean Autosomal Heterozygosity vs Mean X Chromosome Heterozygosity"

# Make labels for axes/legends
cols <- c("blue", "red")
mf <- c("male", "female")
xintenlab <- paste("X intensity (n=", nx, ")", sep = "")
yintenlab <- paste("Y intensity (n=", ny, ")", sep = "")

# Make the 4 plots and add a legend
par(mfrow = c(2, 2))
plot(
  x1,
  y1,
  xlab = xintenlab,
  ylab = yintenlab,
  main = main1,
  col = xcol,
  cex.main = 0.8
)
legend("bottomleft",
       mf,
       col = cols,
       pch = c(1, 1),
       cex = 0.5)
plot(
  x2,
  y2,
  col = xcol,
  xlab = xintenlab,
  ylab = "X heterozygosity",
  main = main2,
  cex.main = 0.8
)
plot(
  x3,
  y3,
  col = xcol,
  ylab = yintenlab,
  xlab = "X heterozygosity",
  main = main3,
  cex.main = 0.8
)
plot(
  x4,
  y4,
  col = "red",
  xlab = "Autosomal heterozygosity",
  ylab = "X heterozygosity",
  main = main4,
  cex.main = 0.8
)
par(mfrow = c(1, 1))

```

## Part 2 - Report (Sex Check)

-   [Describe any anomalies you see in the 4 plots above.]{.underline}

    -   There are a few abnormalities in these plots– what appears to be some mislabels from male -\> female. There are a couple points labeled female but have high Y intensity, and points marked female that have low X heterozygosity.

-   [Figure out the scanIDs of any scans that look like outliers or possible instances of mislabeled sex. Include these IDs in your report and describe why they appear to be mislabeled.]{.underline}

    -   scanID 325 and scanID 326 seem to be mislabeled. These are labeled as female, but they have high het.Y values and no het.X values.

-   [For the purposes of this assignment we will ASSUME that some scans have just had their sexes mislabeled. (In "real life", we would not just assume this, and we might instead flag these scans for removal from some downstream steps/analyses.)]{.underline}

-   [Manually change the sex annotation for these scans in scanAnnot to "remove" the discrepancy. (Manually changing your data is risky and not generally recommended. Be careful!). In your report, state exactly what changes you made. Add a new column to scanAnnot indicating this, too (add appropriate metadata). Does anything in the pedigree structure make you more confident that this "fix" is correct? (Are these samples labeled as mothers or fathers?)]{.underline}

    -   I found the two scanIDs labeled female with 0 het.X values, and changed their sex from F -\> M. To confirm, I checked the individual (both scanIDs are from one subjectID) in the pedigree, and they are labeled as a father.

-   [Remake the 4 plots above, using the "corrected" data (nothing should appear mislabeled now for this dataset).]{.underline}

    -   See coding block below.

-   [How might you follow up on this "in real life"?]{.underline}

    -   Alert the PI that there were some sex discrepancies, which should now have been corrected.

```{r part2_report_sex_check}

#   <Your code goes here>
sc <- pData(scanAnnot)

# Figure out the scanIDs of any scans that look like outliers or possible instances of mislabeled sex.
sc %>%
  filter(het.X < 0.1 & sex == 'F') # 0.1 is a bit of an arbitrary threshold, but I looked at the graphs and saw that there was a significant gap around this area

# Manually change the sex annotation for these scans in scanAnnot to "remove" the discrepancy. 
pData(scanAnnot)$sex[pData(scanAnnot)$sex == 'F' & pData(scanAnnot)$het.X < 0.1 ] <- 'M'
sc %>%
  filter(scanID == 325 | scanID == 326)
sc %>%
  filter(father == 200094287) # scanIDs listed above-- they're a father


# Remake the 4 plots above, using the "corrected" data (nothing should appear mislabeled now for this dataset).
#   Extract the matrix containing the mean intensity for each chromosome for
#   each scan
# names(inten.by.chrom)
# mninten <- inten.by.chrom$mean.intensity

#   Before making the plots, there are a few things to do

#   We want to color the plotted points by annotated sex
#   Now we assign each sex a color (male=blue, female=red)
#   Store the colors in a vector
xcol <- rep(NA, nrow(scanAnnot))
xcol[scanAnnot$sex == "M"] <- "blue"
xcol[scanAnnot$sex == "F"] <- "red"

#   We also want to count the number of SNPs getting included on the X and Y
#   chromosomes (which are coded as 23 and 25 in snpAnnot)
nx <- sum(snpAnnot$chromosome == 23)
ny <- sum(snpAnnot$chromosome == 25)

# Now make the plots

# All intensities
x1 <- mninten[, "X"]
y1 <- mninten[, "Y"]
main1 <- "Mean X vs \nMean Y Chromosome Intensity"

# Het on X vs X intensity
x2 <- mninten[, "X"]
y2 <- scanAnnot$het.X
main2 <-
  "Mean X Chromosome Intensity vs Mean X Chromosome Heterozygosity"

# Het on X vs Y intensity
y3 <- mninten[, "Y"]
x3 <- scanAnnot$het.X
main3 <-
  "MeanX Chromosome Heterozygosity vs Mean Y Chromosome Intensity"

# X vs A het
x4 <- scanAnnot$het.A[scanAnnot$sex == "F"]
y4 <- scanAnnot$het.X[scanAnnot$sex == "F"]
main4 <-
  "Mean Autosomal Heterozygosity vs Mean X Chromosome Heterozygosity"

# Make labels for axes/legends
cols <- c("blue", "red")
mf <- c("male", "female")
xintenlab <- paste("X intensity (n=", nx, ")", sep = "")
yintenlab <- paste("Y intensity (n=", ny, ")", sep = "")

# Make the 4 plots and add a legend
par(mfrow = c(2, 2))
plot(
  x1,
  y1,
  xlab = xintenlab,
  ylab = yintenlab,
  main = main1,
  col = xcol,
  cex.main = 0.8
)
legend("bottomleft",
       mf,
       col = cols,
       pch = c(1, 1),
       cex = 0.5)
plot(
  x2,
  y2,
  col = xcol,
  xlab = xintenlab,
  ylab = "X heterozygosity",
  main = main2,
  cex.main = 0.8
)
plot(
  x3,
  y3,
  col = xcol,
  ylab = yintenlab,
  xlab = "X heterozygosity",
  main = main3,
  cex.main = 0.8
)
plot(
  x4,
  y4,
  col = "red",
  xlab = "Autosomal heterozygosity",
  ylab = "X heterozygosity",
  main = main4,
  cex.main = 0.8
)
par(mfrow = c(1, 1))
```

## Part 3 - Allelic Imbalance; BAF and LRR Plots

Here we want to look at B allele frequency (BAF) and log R ratio (LRR) plots using `chromIntensityPlot()`. Ordinarily, since there are 22 to 23 chromosomes to check for every sample, you would use a script that automatically detects aberrations in BAF and LRR. For this project, we'll pretend that our pipeline has already flagged one sample for a possible chromosomal anomaly.

```{r baflrr, eval=FALSE}

# Recall that earlier we read the intensity data into an IntensityData object
# called blData.

# The snp/scan annotation were attached as well.

# Suppose that chromosome 22 was flagged for scanID 286.

# Making the BAF/LRR plot is easy

#dev.off()
chromIntensityPlot(blData, scan.ids = 286, chrom.ids = 22)
par(mfrow = c(1, 1))

```

## Part 3 - Report

-   [Describe the purpose of this step.]{.underline}

    -   We would like to check if there are chromosomal abnormalities in this data, so we can remove abnormal samples.

-   [Show an example of a "normal" pair of BAF/LRR plots (choose any chromosome/scanID you want).]{.underline}

    -   Chromosome 21 on scanID 280 appears to have very typical BAF/LRR plots. See coding chunk below.

-   [How would you detect trisomy 21 (i.e., describe briefly in words what the BAF/LRR plot would look like).]{.underline}

    -   There would be 4 bands instead of 3 on the BAF plot, and a positive shift (\>0) on the LRR plot.

-   [Suppose an individual had a balanced reciprocal translocation involving chromosome 2 and 4. What would you expect that individual's BAF/LRR plots would look like for those chromosomes?]{.underline}

    -   Since a balanced reciprocal translocation is essentially a "segment swap" with no gain/loss of DNA, provided an individual's chromosomes 2 and 4 showed no abnormalities, the BAF/LRR plots should look reasonably standard.

        -   <https://www.genomicseducation.hee.nhs.uk/genotes/knowledge-hub/visual-communication-aid-reciprocal-chromosome-translocations/>

-   [Suppose chromosome 22 in sample 286 was the only chromosome flagged for a possible anomaly in this dataset. Looking at the plot, do you notice anything strange? Can you suggest what kind of anomaly might be showing up? (There isn't any single answer that's certainly right! The purpose of this question is to check that you understand what the BAF and LRR plots "mean").]{.underline}

    -   Chromosome 22 doesn't seem unusual. The LRR plot remains at 0, and the BAF plot has three bands representing AA/AB/BB (with the heterozygous band in the very middle of the plot). Though, there is a small empty area in the middle band between 25-30 of the BAF plot, which could have led to the lag.

-   [Finally, suppose your pipeline has given you a list of the exact chromosomal segments showing possibly aneuploidies/anomalies in each sample. What would you recommend doing with the genotypes in those segments? (You're not being asked to implement this here - just say what you recommend doing.)]{.underline}

    -   I would remove any abnormalities.

```{r part3_report}

#  <Your code goes here>
# Show an example of a "normal" pair of BAF/LRR plots (choose any chromosome/scanID you want).
chromIntensityPlot(blData, scan.ids = 280, chrom.ids = 21)
par(mfrow = c(1, 1))
```

**NOTE: I, Caylin Grove, Ceceilagh Pitstick, and Shane Buckley, reviewed our code with each other after we finished the assignment.**
